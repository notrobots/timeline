package dev.notrobots.timeline.ui.tumblr

import android.graphics.Bitmap
import android.os.Bundle
import android.webkit.CookieManager
import android.webkit.WebView
import android.webkit.WebViewClient
import androidx.appcompat.app.AppCompatActivity
import androidx.core.view.isGone
import androidx.lifecycle.lifecycleScope
import com.mgiorda.oauth.HttpMethod
import com.mgiorda.oauth.OAuthConfigBuilder
import com.tumblr.jumblr.JumblrClient
import dev.notrobots.androidstuff.extensions.viewBindings
import dev.notrobots.androidstuff.util.Logger
import dev.notrobots.timeline.data.TUMBLR_USER_AGENT
import dev.notrobots.timeline.databinding.ActivityTwitterLoginBinding
import dev.notrobots.timeline.db.ProfileDao
import dev.notrobots.timeline.models.Profile
import dev.notrobots.timeline.models.Socials
import dev.notrobots.timeline.util.SocialManager
import io.github.redouane59.twitter.TwitterClient
import io.github.redouane59.twitter.signature.TwitterCredentials
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import net.dean.jraw.http.HttpRequest
import net.dean.jraw.http.OkHttpNetworkAdapter
import net.dean.jraw.http.UserAgent
import okhttp3.HttpUrl
import okhttp3.OkHttpClient
import org.apache.http.HttpHeaders.USER_AGENT
import org.json.JSONObject
import javax.inject.Inject

class TumblrLoginActivity : AppCompatActivity() {
    //TODO: Either create one for each login activity or a generic one since it's just a webview
    private val binding by viewBindings<ActivityTwitterLoginBinding>()
    private val logger = Logger(this)

    @Inject
    protected lateinit var profileDao: ProfileDao

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(binding.root)

        val TUMBLR_CONSUMER_KEY = "TUMBLR_CONSUMER_KEY"
        val TUMBLR_CONSUMER_SECRET = "TUMBLR_CONSUMER_SECRET"
        var temporaryCredentials: Map<String, String> = mapOf()
        val http = OkHttpNetworkAdapter(UserAgent(TUMBLR_USER_AGENT), OkHttpClient())

        lifecycleScope.launch(Dispatchers.Default) {
            // TODO These needs to be stored in the environment variables for security reasons

            // https://www.tumblr.com/oauth/authorize
            val temporaryCredentialsRequestOauthConfig = OAuthConfigBuilder(TUMBLR_CONSUMER_KEY, TUMBLR_CONSUMER_SECRET)
//            .setTokenKeys("myAccessKey", "myAccessSecret")
                .build()
            val temporaryCredentialsRequestSignature = temporaryCredentialsRequestOauthConfig.buildSignature(HttpMethod.GET, "https://www.tumblr.com/oauth/authorize")
//            .addQueryParam("aParam", "aValue")
//            .addFormUrlEncodedParam("myParam", "anotherValue")
                .create()

            logger.logi("Authorization: " + temporaryCredentialsRequestSignature.asHeader)

            val temporaryCredentialsRequest = HttpRequest.Builder()
                .secure()
                .host("www.tumblr.com")
                .path("/oauth/request_token")
                .header(USER_AGENT, TUMBLR_USER_AGENT)
                .header(
                    "Authorization", temporaryCredentialsRequestSignature.asHeader

//                """
//                    oauth_consumer_key="$TUMBLR_CONSUMER_KEY",
//                    oauth_signature_method="HMAC-SHA1",
//                    oauth_timestamp="${now()}",
//                    oauth_nonce="TUMBLR_OAUTH_NONCE",
//                    oauth_version="1.0",
//                    oauth_signature="TUMBLR_OAUTH_SIGNATURE"
//                """.trimIndent()    // Signature generated by postman
                )
                .method("post", mapOf())
                .build()

            val temporaryCredentialsResponse = http.execute(temporaryCredentialsRequest)

            if (temporaryCredentialsResponse.code != 200) {
                logger.loge("Response code: ${temporaryCredentialsResponse.code}")
                logger.loge(temporaryCredentialsResponse.body)
                setResult(RESULT_ERROR)
                finish()
                return@launch
            }

            temporaryCredentials = temporaryCredentialsResponse.body.split("&").associate {
                val separatorIndex = it.indexOf("=")

                it.substring(0, separatorIndex) to it.substring(separatorIndex + 1)
            }

            if ("oauth_token" !in temporaryCredentials || "oauth_token_secret" !in temporaryCredentials) {
                logger.loge("Missing parameters oauth_token and/or oauth_token_secret")
                setResult(RESULT_ERROR)
                finish()
                return@launch
            }

            // https://www.tumblr.com/oauth/authorize
            val resourceOwnerAuthorizationRequest = HttpRequest.Builder()
                .secure()
                .host("www.tumblr.com")
                .path("/oauth/authorize")
                .header(USER_AGENT, TUMBLR_USER_AGENT)
                .query(
                    mapOf(
                        "oauth_token" to temporaryCredentials["oauth_token"]!!
                    )
                )
                .build()

            binding.webView.loadUrl(resourceOwnerAuthorizationRequest.url)
        }

        CookieManager.getInstance().removeAllCookies(null)
        CookieManager.getInstance().flush()

        binding.webView.clearCache(true)
        binding.webView.clearHistory()
        binding.webView.settings.javaScriptEnabled = true
        binding.webView.webViewClient = object : WebViewClient() {
            override fun onPageStarted(view: WebView, url: String, favicon: Bitmap?) {
                super.onPageStarted(view, url, favicon)

                val url = HttpUrl.parse(url)

                // Skip until the url is the same as the redirect uri
                if (url == null || !url.toString().startsWith("http://localhost:8080")) {
                    return
                }

//                val error = url.queryParameter("error")
//
//                if (error != null) {
//                    setResult(500)
//                    logger.loge("OAuth2 error: $error")
//                    finish()
//                    return
//                }

                val oauthToken = url.queryParameter("oauth_token")
                val oauthVerifier = url.queryParameter("oauth_verifier")
                val source = url.queryParameter("source")

                if (oauthToken == null) {
                    setResult(RESULT_ERROR)
                    logger.loge("Query parameter 'oauthToken' is missing")
                    finish()
                    return
                }

                if (oauthVerifier == null) {
                    setResult(RESULT_ERROR)
                    logger.loge("Query parameter 'oauthVerifier' is missing")
                    finish()
                    return
                }

                view.stopLoading()
                view.isGone = true

                lifecycleScope.launch(Dispatchers.Default) {
                    try {
                        val tokenRequestOauthConfig = OAuthConfigBuilder(TUMBLR_CONSUMER_KEY, TUMBLR_CONSUMER_SECRET)
                            .setTokenKeys(temporaryCredentials["oauth_token"], temporaryCredentials["oauth_token_secret"])
                            .build()
                        val tokenRequestSignature = tokenRequestOauthConfig.buildSignature(HttpMethod.GET, "https://www.tumblr.com/oauth/access_token")
//            .addQueryParam("aParam", "aValue")
//            .addFormUrlEncodedParam("myParam", "anotherValue")
                            .create()

                        // https://www.tumblr.com/oauth/access_token
                        val tokenRequest = HttpRequest.Builder()
//                            .secure(true)
                            .host("www.tumblr.com")
                            .path("/oauth/access_token")
                            .header(USER_AGENT, TUMBLR_USER_AGENT)
                            .header("Content-Type", "application/x-www-form-urlencoded")
                            .header("Authorization", tokenRequestSignature.asHeader)
//                            .header("Authorization", """
//                                oauth_consumer_key="$TUMBLR_CONSUMER_KEY",
//                                oauth_signature_method="HMAC-SHA1",
//                                oauth_timestamp="1675252971",
//                                oauth_nonce="TUMBLR_OAUTH_NONCE",
//                                oauth_version="1.0",
//                                oauth_signature="TUMBLR_OAUTH_SIGNATURE"
//                            """.trimIndent())
                            .post(
                                mapOf(
                                    "oauth_verifier" to oauthVerifier,
//                                    "grant_type" to "authorization_code",
//                                    "redirect_uri" to "http://localhost:8080",
//                                    "code_verifier" to SocialManager.deviceUuid.toString(),
//                                    "client_id " to "TWITTER_CLIENT_ID"
                                )
                            )
                            .basicAuth("TWITTER_CLIENT_ID" to "")
                            .build()

                        val tokenResponse = http.execute(tokenRequest)
                        val json = JSONObject(tokenResponse.body)
                        val oauthToken = json.getString("oauth_token")
                        val oauthTokenSecret = json.getString("oauth_token_secret")

                        val tumblrClient = JumblrClient(
                            TUMBLR_CONSUMER_KEY,
                            TUMBLR_CONSUMER_SECRET,
                            oauthToken,
                            oauthTokenSecret
                        )
                        val username = tumblrClient.user().name

                        if (profileDao.exists(username, Socials.Tumblr)) {
                            //xxx: Refresh token if needed?
                            setResult(RESULT_ALREADY_LOGGED_IN)
                        } else {
                            val newProfile = Profile(
                                username,
                                Socials.Tumblr
                            )

                            profileDao.insert(newProfile).also {
                                newProfile.profileId = it
                            }

                            SocialManager.tumblrAddNewProfile(newProfile)
                            setResult(RESULT_OK)
                        }
                    } catch (_: Exception) {
                        setResult(RESULT_CANCELED)
                    } finally {
                        finish()
                    }
                }
            }
        }
    }

    companion object {
        const val RESULT_CANCELED = 0
        const val RESULT_OK = 100
        const val RESULT_ALREADY_LOGGED_IN = 200
        const val RESULT_ERROR = 300
    }
}